---
title: LC 141 - Linked List Cycle
date: 2024-08-04 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, linked_list]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

    Input: head = [3,2,0,-4], pos = 1
    Output: true

**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

    Input: head = [1,2], pos = 0
    Output: true

**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

    Input: head = [1], pos = -1
    Output: false

**Explanation:** There is no cycle in the linked list.

**Constraints:**

- The number of the nodes in the list is in the range `[0, 104]`.
- `-105 <= Node.val <= 105`
- `pos` is `-1` or a **valid index** in the linked-list.

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

## Links
Question [here](https://leetcode.com/problems/linked-list-cycle/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/easy/141_linked_list_cycle/solution.py)

## Solution

### concept

We can use a hashset to track visited node.

Alternatively, we can use a two pointers (slow and fast) and see if they can meet. **Note that slow will advance one step while fast will advance two step.** This will make sure that the fast pointer will catch up the slow pointer if there is a loop.
Since on average the fast pointer moves 1 step w.r.t. the slow pointer, it will guaranteed to catch up the slow pointer in the loop and the time complexity is $O(n)$

### code
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
	"""
	hashset
	"""
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()
        cur = head

        while cur is not None:
            if cur in visited:
                return True
            visited.add(cur)
            cur = cur.next

        return False

class Solution:
	"""
	Floyd's tortoise and Hare
	fast and slow pointer
	"""
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        
        return False
```

## Complexity

time: $O(n)$      
space: $O(n)$ if hashset, $O(1)$ if Floyd's tortoise and hare. 