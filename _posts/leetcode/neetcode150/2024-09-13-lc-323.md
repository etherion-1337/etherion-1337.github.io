---
title: LC 323 - Number of Connected Components in an Undirected Graph
date: 2024-09-13 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, graphs]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.

Return _the number of connected components in the graph_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/conn1-graph.jpg)

    Input: n = 5, edges = [[0,1],[1,2],[3,4]]
    Output: 2

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/14/conn2-graph.jpg)

    Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]
    Output: 1

**Constraints:**

- `1 <= n <= 2000`
- `1 <= edges.length <= 5000`
- `edges[i].length == 2`
- `0 <= ai <= bi < n`
- `ai != bi`
- There are no repeated edges.

## Links
Question [here](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/323_number_of_connected_components_in_an_undirected_graph/solution.py)

## Solution

### concept
We can use DFS on each node to gather all nodes into a `visited` set. If we start on a new node and this node is not in the `visited` set then this node belongs to a new group. The solution is quite similar to [[261. Graph Valid Tree]] but we will calculate the number of groups.

### code
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        adj_list = {i : [] for i in range(n)}
        for node_1, node_2 in edges:
            adj_list[node_1].append(node_2)
            adj_list[node_2].append(node_1)

        visited = set()

        def dfs(node, parent):
            if node in visited:
                return
            
            visited.add(node)
            for nei in adj_list[node]:
                if nei == parent:
                    continue
                dfs(nei, node)
        ans = 0
        for i in range(n):
            if i not in visited:
                ans += 1
                dfs(i, -1)
    
        return ans
```

## Complexity
time: $O(V + E)$      
space: $O(V + E)$ 