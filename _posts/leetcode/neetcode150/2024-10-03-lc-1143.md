---
title: LC 1143 - Longest Common Subsequence
date: 2024-10-03 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, 2d_dp]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

Given two strings `text1` and `text2`, return _the length of their longest **common subsequence**._ If there is no **common subsequence**, return `0`.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

- For example, `"ace"` is a subsequence of `"abcde"`.

A **common subsequence** of two strings is a subsequence that is common to both strings.

**Example 1:**

    Input: text1 = "abcde", text2 = "ace" 
    Output: 3  

**Explanation:** The longest common subsequence is "ace" and its length is 3.

**Example 2:**

    Input: text1 = "abc", text2 = "abc"
    Output: 3

**Explanation:** The longest common subsequence is "abc" and its length is 3.

**Example 3:**

    Input: text1 = "abc", text2 = "def"
    Output: 0

**Explanation:** There is no such common subsequence, so the result is 0.

**Constraints:**

- `1 <= text1.length, text2.length <= 1000`
- `text1` and `text2` consist of only lowercase English characters.

## Links
Question [here](https://leetcode.com/problems/longest-common-subsequence/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/1143_longest_common_subsequence/solution.py)

## Solution

### concept
From the brute force solution, we can see that whenever we have a match char, i.e. `text1[i] == text2[j]`, we can search the next index of both of the strings (and plus 1 to the next search since we found one char in the LCS). If we do not see a match, we can then DFS the next index of either the string and get the maximum of the two.

The bottom-up solution is pretty much the same. Imagine we put the two string in the 2D board, with an extra col and row equal to 0 for ease of calculations.
Whenever we see that the char matches, we take the diagonal (bottom-right) value and +1.
Whenever the char does not match, this cell is the `max(right cell, bottom cell)`

Each cell is the LCS of the `text1[i:]` and `text[j:]` 
![image](/assets/posts/leetcode/neetcode150/lc_1143.png)

### code
```python
class Solution:
	"""
	brute force backtracking
	TLE
	"""
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        def dfs(i,j):
            if i == len(text1) or j == len(text2):
                return 0

            if text1[i] == text2[j]:
                ans = 1 + dfs(i+1, j+1)
            else:
                ans = max(dfs(i+1,j), dfs(i, j+1))

            return ans
        
        return dfs(0,0)

class Solution:
	"""
	top down solution: memoization
	"""
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        # (i,j) -> longest common subsequence at that i,j
        cache = {}
        def dfs(i,j):
            if i == len(text1) or j == len(text2):
                return 0
            if (i,j) in cache:
                return cache[(i,j)]

            if text1[i] == text2[j]:
                ans = 1 + dfs(i+1, j+1)
            else:
                ans = max(dfs(i+1,j), dfs(i, j+1))
            cache[(i,j)] = ans
            return cache[(i,j)]
        
        return dfs(0,0)

class Solution:
	"""
	bottom up solution
	"""
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]

        for i in range(len(text1)-1, -1, -1):
            for j in range(len(text2)-1, -1, -1):
                if text1[i] == text2[j]:
                    dp[i][j] = 1 + dp[i+1][j+1]
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j+1])

        return dp[0][0]
```

## Complexity
time: $O(mn)$          
space: $O(mn)$ 