---
title: LC 435 - Non-overlapping Intervals
date: 2024-10-20 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, intervals]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Note** that intervals which only touch at a point are **non-overlapping**. For example, `[1, 2]` and `[2, 3]` are non-overlapping.

**Example 1:**

    Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
    Output: 1

**Explanation:** [1,3] can be removed and the rest of the intervals are non-overlapping.

**Example 2:**

    Input: intervals = [[1,2],[1,2],[1,2]]
    Output: 2

**Explanation:** You need to remove two [1,2] to make the rest of the intervals non-overlapping.

**Example 3:**

    Input: intervals = [[1,2],[2,3]]
    Output: 0

**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.

**Constraints:**

- `1 <= intervals.length <= 105`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 104`

## Links
Question [here](https://leetcode.com/problems/non-overlapping-intervals/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/435_non_overlapping_intervals/solution.py)

## Solution

### concept
1. We first sort the intervals (either by start or end, start will be a bit more intuitive)
2. we keep track the current ending point in `prev_end`
3. As we iterate through the intervals, we need to check:
	1. if the current interval is overlapping with the previous intervals
		1. by checking if `start >= prev_end`, if true means it is not overlapping. Since it is sorted, we are sure the current start is >= prev_start so this condition is enough. 
		2. If true, we will update `prev_end` to the current interval, since they are not overlapping.
	2. if the current interval is overlapping:
		1. we need to remove the interval with **larger end point** to maximize the likelihood that the future intervals won't be overlapping current intervals.

### code
```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        prev_end = intervals[0][1]
        ans = 0

        for start, end in intervals[1:]:
            if start >= prev_end:
                prev_end = end
            else:
                ans += 1
                prev_end = min(prev_end, end)

        return ans
```

## Complexity
time: $O(n \log n)$       
space: $O(n)$ 