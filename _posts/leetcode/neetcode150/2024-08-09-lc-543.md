---
title: LC 543 - Diameter of Binary Tree
date: 2024-08-09 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, trees]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Given the `root` of a binary tree, return _the length of the **diameter** of the tree_.

The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The **length** of a path between two nodes is represented by the number of edges between them.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

    Input: root = [1,2,3,4,5]
    Output: 3

**Explanation:** 3 is the length of the path `[4,2,1,3] or [5,2,1,3]`.

**Example 2:**

    Input: root = [1,2]
    Output: 1

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `-100 <= Node.val <= 100`

## Links
Question [here](https://leetcode.com/problems/diameter-of-binary-tree/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/easy/543_diameter_of_binary_tree/solution.py)

## Solution

### concept

This question is a bit similar to [[104. Maximum Depth of Binary Tree]] in the sense we would like to keep track the depth or height of the tree.
The easy way is to use DFS to traverse the tree. The key thing here is to *keep track the diameter in a global variable but in the DFS function we return the height of the tree*.
The reason is we can get the diameter by adding the left and right height of the current node and height is sort of invariant in the calculation here.
If we return maximum diameter, this maximum length path might not even pass the current root, but by keeping the height from both side, we can keep track the diameter.

### code

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.ans = 0

        def dfs(curr):
            if not curr:
                return 0 # height of the current tree

            h_left = dfs(curr.left)
            h_right = dfs(curr.right)

            self.ans = max(self.ans, h_left + h_right)
            return 1 + max(h_left, h_right)

        dfs(root)

        return self.ans
```

## Complexity

Time complexity: $O(n)$
Space complexity: $O(h)$
- Best Case ([balanced tree](https://www.geeksforgeeks.org/balanced-binary-tree/)): $O(\log(n))$
- Worst Case ([degenerate tree](https://www.geeksforgeeks.org/introduction-to-degenerate-binary-tree/)): $O(n)$
