---
title: LC 7 - Reverse Integer
date: 2024-10-27 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, bit_manipulation]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.

**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**

**Example 1:**

    Input: x = 123
    Output: 321

**Example 2:**

    Input: x = -123
    Output: -321

**Example 3:**

    Input: x = 120
    Output: 21

**Constraints:**

- `-231 <= x <= 231 - 1`

## Links
Question [here](https://leetcode.com/problems/reverse-integer/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/7_reverse_integer/solution.py)

## Solution

### concept

Nil

### code
```python
class Solution:
    def reverse(self, x: int) -> int:
        MIN = -2147483648 # -2^31
        MAX = 2147483647 # 2^31 - 1
        
        ans = 0
        while x:
            # in python for -ve num, e.g. -1%10 = 9, so we use a math lib
            digit = int(math.fmod(x,10))
            # in python for -ve num, e.g. -1//10 = -1. so we do it this way for int div
            x = int(x/10)
            # we cannot access num > 2147483647 directly due to 32 bit restriction
            # so we compare 214748364 first, if our reversed value is larger than this, then for sure curr_num*10 will be larger
            if (ans > MAX//10 or
               (ans == MAX//10 and digit >= MAX%10)):
               return 0 
            if (ans < MIN//10 or
               (ans == MIN//10 and digit <= MIN%10)):
               return 0
            ans = (ans*10)+digit
        return ans
```

## Complexity
time: $O(1)$     
space: $O(1)$ 