---
title: LC 79 - Word Search
date: 2024-08-28 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, backtracking]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
    Output: true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
    Output: true

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
    Output: false

**Constraints:**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` and `word` consists of only lowercase and uppercase English letters.

**Follow up:** Could you use search pruning to make your solution faster with a larger `board`?

## Links
Question [here](https://leetcode.com/problems/word-search/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/79_word_search/solution.py)

## Solution

### concept
We use backtracking on every cells. Each backtracking is essentially a DFS on 4 directions.

### code
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        ROW, COL = len(board), len(board[0])
        path = set()

        def dfs(r, c, idx):
            if idx == len(word):
                return True
            if (r < 0 or c < 0 or
                r >= ROW or c >= COL or
                board[r][c] != word[idx] or
                (r,c) in path):
                return False

            path.add((r,c))
            ans = (dfs(r + 1, c, idx + 1) or
                    dfs(r - 1, c, idx + 1) or
                    dfs(r, c + 1, idx + 1) or
                    dfs(r , c - 1, idx + 1))
            path.remove((r,c))
            return ans

        for r in range(ROW):
            for c in range(COL):
                exist = dfs(r, c, 0)
                if exist:
                    return True
        return False
```

## Complexity
time: $O(m*4^n)$, where $m$ is the number of cells in the board and $n$ is the length of the word.      
space: $O(n)$ 