---
title: LC 763 - Partition Labels
date: 2024-10-18 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, greedy]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string `"ababcc"` can be partitioned into `["abab", "cc"]`, but partitions such as `["aba", "bcc"]` or `["ab", "ab", "cc"]` are invalid.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.

Return _a list of integers representing the size of these parts_.

**Example 1:**

    Input: s = "ababcbacadefegdehijhklij"
    Output: [9,7,8]

**Explanation:**
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.

**Example 2:**

    Input: s = "eccbbbbdec"
    Output: [10]

**Constraints:**

- `1 <= s.length <= 500`
- `s` consists of lowercase English letters.

## Links
Question [here](https://leetcode.com/problems/partition-labels/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/763_partition_labels/solution.py)

## Solution

### concept
first build a hash map to store the last index of each char in s
then we iterate through s, for each char we update the end index of the current partition (imagine there is a boundary indicating the partition, but this boundary gets pushed back if there exist a char whose last index is beyond this current boundary, so this boundary has to be pushed back, to ensure all char within the current partition is included.)
this is to make sure all char so far in the current partition are all included in the current partition

### code
```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        # key: char
        # val: last index of char appeared in s
        hash_map = {}
        for i, char in enumerate(s):
            hash_map[char] = i

        result = []
        # size of current partition
        curr_size = 0
        # the end index of current partition
        curr_end = 0
        for i, char in enumerate(s):
            curr_size += 1
            curr_end = max(curr_end, hash_map[char])

            if i == curr_end:
                result.append(curr_size)
                # no need reset curr_end since the max func will update in the start of the next partition
                curr_size = 0

        return result
```

## Complexity
time: $O(n)$      
space: $O(1)$ 