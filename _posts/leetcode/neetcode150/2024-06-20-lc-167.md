---
title: LC 167 - Two Sum II Input Array Is Sorted
date: 2024-06-20 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, two_pointers]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.

Return the indices of the two numbers, $\text{index}_1$ and  $\text{index}_2$, **added by one** as an integer array $[\text{index}_1, \text{index}_2]$ of length 2.

The tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.

Your solution must use only constant extra space.

**Example 1:**

    Input: numbers = [2,7,11,15], target = 9
    Output: [1,2]

**Explanation:** The sum of 2 and 7 is 9. Therefore, $\text{index}_1$ = 1, $\text{index}_2$ = 2. We return `[1, 2]`.

**Example 2:**

    Input: numbers = [2,3,4], target = 6
    Output: [1,3]

**Explanation:** The sum of 2 and 4 is 6. Therefore $\text{index}_1$ = 1, $\text{index}_2$ = 3. We return `[1, 3]`.

**Example 3:**

    Input: numbers = [-1,0]`, target = -
    Output: [1,2]

**Explanation:** The sum of -1 and 0 is -1. Therefore $\text{index}_1$ = 1, $\text{index}_2$ = 2. We return `[1, 2]`.

**Constraints:**

- `2 <= numbers.length <= 3 * 104`
- `-1000 <= numbers[i] <= 1000`
- `numbers` is sorted in **non-decreasing order**.
- `-1000 <= target <= 1000`
- The tests are generated such that there is **exactly one solution**.

## Links
Question [here](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description) and Solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/167_two_sum_ii/solution.py)

## Solution

### concept
Since the array is sorted, we use a `left` and `right` pointer to keep track the `curSum = numbers[l] + numbers[r]`.
If `curSum > target`, we will move `right` to the left and if `curSum < target`, we will move `left` to the right.
If the condition `curSum == target`, then it is the answer.
This works because the array is _sorted_.

### code
```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers) - 1

        while l < r:
            curSum = numbers[l] + numbers[r]

            if curSum > target:
                r -= 1
            elif curSum < target:
                l += 1
            else:
                return [l + 1, r + 1]
        return []
```

## Complexity
time: $O(n)$     
space: $O(1)$