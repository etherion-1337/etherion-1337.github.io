---
title: LC 56 - Merge Intervals
date: 2024-10-20 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, intervals]     # TAG names should always be lowercase
toc: true
math: true
mermaid: true
---

## Question

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

    Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
    Output: [[1,6],[8,10],[15,18]]

**Explanation:** Since intervals `[1,3]` and `[2,6]` overlap, merge them into `[1,6]`.

**Example 2:**

    Input: intervals = [[1,4],[4,5]]
    Output: [[1,5]]

**Explanation:** Intervals `[1,4]` and `[4,5]` are considered overlapping.

**Example 3:**

    Input: intervals = [[4,7],[1,4]]
    Output: [[1,7]]

**Explanation:** Intervals `[1,4]` and `[4,7]` are considered overlapping.

**Constraints:**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

## Links
Question [here](https://leetcode.com/problems/merge-intervals/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/56_merge_intervals/solution.py)

## Solution

### concept
We sort the intervals by the starting point and iterative through each intervals.
We do not need to worry about the starting point here since it is already sorted.

### code
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda i : i[0])
        ans = [intervals[0]]

        for start, end in intervals[1:]:
            if start <= ans[-1][1]:
                ans[-1][1] = max(ans[-1][1], end)
            else:
                ans.append([start, end])

        return ans
```

## Complexity
time: $O(n\log n)$      
space: $O(n)$ 