---
title: LC 78 - Subsets
date: 2024-08-24 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, backtracking]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

**Example 1:**

    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**Example 2:**

    Input: nums = [0]
    Output: [[],[0]]

**Constraints:**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the numbers of `nums` are **unique**.

## Links
Question [here](https://leetcode.com/problems/subsets/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/78_subsets/solution.py)

## Solution

### concept
Standard backtrack algorithm. Take note the way we add the elements into the subsets in the `include` path, and then when we are backtracking we have to remove the element (i.e. choose to `exclude` current element). By design there will not be any duplicate.
Also take note that since we are advancing the `idx` at every step, this means the same element is used only **once**.
![image](/assets/posts/leetcode/neetcode150/backtrack_subset_lc.png)

### code
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        subset = []

        def dfs(idx):
            if idx >= len(nums):
                ans.append(subset.copy())
                return

            # include current element
            subset.append(nums[idx])
            dfs(idx + 1)

            # do not include current element
            subset.pop()
            dfs(idx + 1)

        dfs(0)

        return ans
```

## Complexity
time: $O(n * 2^n)$       
space: $O(n)$ extra space and $O(2^n)$