---
title: LC 297 - Serialize and Deserialize Binary Tree
date: 2024-08-17 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, trees]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

    Input: root = [1,2,3,null,null,4,5]
    Output: [1,2,3,null,null,4,5]

**Example 2:**

    Input: root = []
    Output: []

**Constraints:**

- The number of nodes in the tree is in the range `[0, 104]`.
- `-1000 <= Node.val <= 1000`

## Links
Question [here](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/hard/297_serialize_and_deserialize_binary_tree/solution.py)

## Solution

### concept
Normally we will need both inorder and preorder/postorder traversal to fully define a tree, but here we can label empty nodes as `Null` and this turns the tree into a **Full Binary Tree** and we can reconstruct the tree with just preorder traversal.

The idea is just run DFS and if we seen a null node (i.e. the current node has no child node and we still DFS down), we will append a `Null` in the path.
We will reconstruct the tree with preorder traversal.

### code

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        output = []

        def dfs(node):
            if not node:
                output.append("Null")
                return
            
            output.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        dfs(root)
        return ",".join(output)
        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        self.idx = 0
        data = data.split(",")

        def dfs():
            if data[self.idx] == "Null":
                self.idx += 1
                return None

            node = TreeNode(int(data[self.idx]))
            self.idx += 1
            node.left = dfs()
            node.right = dfs()
            return node
            
        root = dfs()
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```
## Complexity

time: $O(n)$     
space: $O(n)$ 