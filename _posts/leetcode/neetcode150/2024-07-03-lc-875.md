---
title: LC 875 - Koko Eating Bananas
date: 2024-07-03 0000:00:00 +0800
categories: [LeetCode, NeetCode150]
tags: [leetcode, neetcode150, binary_search]     # TAG names should always be lowercase
toc: true
math: true
---

## Question

Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.

Koko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.

**Example 1:**

    Input: piles = [3,6,7,11], h = 8
    Output: 4

**Example 2:**

    Input: piles = [30,11,23,4,20], h = 5
    Output: 30

**Example 3:**

    Input: piles = [30,11,23,4,20], h = 6
    Output: 23

**Constraints:**

- `1 <= piles.length <= 104`
- `piles.length <= h <= 109`
- `1 <= piles[i] <= 109`

## Links
Question [here](https://leetcode.com/problems/koko-eating-bananas/description/) and solution [here](https://github.com/etherion-1337/LeetCode/blob/master/medium/875_koko_eating_bananas/solution.py)

## Solution

### concept
We will use binary search but the search space is from `[1,...max(piles)]`. Essentially we want to find which number is the minimum that can eat all the piles given time `h`.
The maximum is going to be `max(piles)` since this will allow Koko to finish all the piles in `len(piles)`.

### code
```python
class Solution:
	"""
	binary search
	note that the condition is l <= r
	"""
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        
        def can_finish(rate):
            time = 0
            for p in piles:
                time += math.ceil(p/rate)
            return True if time <= h else False

        l, r = 1, max(piles)
        ans = r
        while l <= r:
            mid = (l + r)//2
            if can_finish(mid):
                ans = min(ans, mid)
                r = mid - 1
            else:
                l = mid + 1

        return ans
        
class Solution:
	"""
	notice the l < r
	"""
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        
        def can_finish(rate):
            time = 0
            for p in piles:
                time += math.ceil(p/rate)
            return True if time <= h else False

        l, r = 1, max(piles)
        while l < r:
            mid = (l + r) // 2
            if can_finish(mid):
                r = mid
            else:
                l = mid + 1
        return l
```        

## Complexity
time: $O(n\log m)$ where $m$ is the max of piles and n is the `len(piles)`      
space: $O(1)$ 